<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Interactive Digital</title>
        <link rel="stylesheet" type="text/css" href="../static/style.css" />
        <link rel="preconnect" href="https://rsms.me/" />
        <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
    </head>

    <body class="px-2">
        <div class="py-4">
            <div class="flex flex-row items-baseline pb-2">
                <a href="/">
                    <div
                        class="text-[calc(50vw/8)] tracking-[-0.03em] leading-none font-semibold"
                    >
                        Interactive Digital
                    </div>
                </a>
                <nav>
                    <a
                        class="text-blue-600 visited:text-purple-600 px-2 py-0.5 ml-4 after:content-['â†—']"
                        href="/posts/posts.html"
                    >
                        <span class="text-sm text-gray-600 font-semibold"
                            >Posts</span
                        >
                    </a>
                </nav>
            </div>
            <hr class="md:hidden" />
        </div>
        <div class="post-content max-w-prose px-2"><h2>Metal ARM x02 - Red LED (Lab Notes)</h2>
<aside>
  Metal ARM is a series of projects for learning native toolchain development and
  embedded programming "from scratch." For additional context, see
  <a href="https://bferris413.github.io/posts/metal_arm_intro.html">this introductory post</a>.
  <br>
  <br>
  This post is formatted as a set of lab/shop notes: rough around the edges, to the point, light on
  prose.
</aside>
<p>Project 2 consists of:</p>
<ul>
<li>Expanding the chasm toolchain until we can turn on the board's red LED.</li>
<li>Writing the assembly program to actually do that.</li>
</ul>
<h2>Work Completed</h2>
<ul>
<li>Added the following instructions to <code>chasm assemble</code>:
<ul>
<li><code>MOVW</code></li>
<li><code>MOVT</code></li>
<li><code>LDR</code></li>
<li><code>ORRS</code></li>
<li><code>STR</code></li>
<li><code>ANDS</code></li>
<li><code>BEQ</code></li>
<li>(most only support the minimum needed for the given context, like 1 or 2 encodings,
no &quot;optional&quot; parameters, no conditions, etc.)</li>
</ul>
</li>
<li>Continued reading a bunch of:
<ul>
<li><a href="https://www.ti.com/lit/ds/symlink/tm4c123gh6pm.pdf?ts=1759278523305&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FTM4C123GH6PM">TM4C123GH6PM Microcontroller data sheet</a> - all board-specific info, like where GPIO ports are located, how to initialize them, etc.</li>
<li><a href="https://developer.arm.com/documentation/ddi0403/ee">ARMv7-M Architecture Reference Manual</a> - instructions and encodings mostly at this point.</li>
</ul>
</li>
<li>Flashed and tested on EK-TM4C123GXL, and we get a solid red LED ðŸŽ‰
<ul>
<li>Used <code>chasm assemble 2.cas</code> on commit <a href="https://github.com/bferris413/chasm-toolchain/tree/b601092026c8f0d11192b516a2ef74d5e528f92f"><code>b601092026c8f0d11192b516a2ef74d5e528f92f</code></a></li>
</ul>
</li>
</ul>
<p>The full assembly program is:</p>
<pre><code class="language-chasm-assembly">; vector table
x2000.8000         ; sp starting address
x0000.0009         ; reset handler address | 1 (thumb mode)

; Reset handler - toggle led

; GPIO Port F, (AHB) base - x4005.D000
; Data register pins at offset x01 (red), x02 (blue), x03 (green)

; 1. enable clock at RCGCGPIO - x400F.E608 
; set bit 5 to 1
MOVW R0 xE608
MOVT R0 x400F
LDR R1 R0
MOVS R2 x20             ; bits[5] = 1
ORRS R1 R2
STR R1 R0

; We need to use the AHB (vs. APB), AHB is the only option supported
; by the board but it's not set on reset
MOVW R0 xE06C 
MOVT R0 x400F
LDR R1 R0
MOVS R2 x20             ; bits[5] = 1
ORRS R1 R2
STR R1 R0

; wait for GPIO F to be ready for use via PRGPIO
MOVW R0 xEA08 
MOVT R0 x400F
MOVS R2 x20

@waitready
    LDR R1 R0
    ANDS R1 R2
    BEQ @waitready

; 2. Set direction of GPIO port F LED pins to output 
; GPIODIR register at offset x400, set pins[1..=3] to 1
MOVW R0 xD400
MOVT R0 x4005
LDR R1 R0
MOVS R2 x0E             ; bits[1..=3] = 1
ORRS R1 R2
STR R1 R0

; 3. Enable as digital I/O
; offset at x51C, pins 1, 2, 3 set to 1
MOVW R0 xD51C
MOVT R0 x4005
LDR R1 R0
MOVS R2 x0E             ; bits[1..=3] = 1
ORRS R1 R2
STR R1 R0

; Set port F pin 1 (red) to 1
; GPOI port F data register is at x4005.D000, and we need to write
; our mask for setting Pin 1 (0b00000010) at addr + (mask &lt;&lt; 2):
; x4005.D000 + (0x02 &lt;&lt; 2) = x4005.D008
MOVW R0 xD008
MOVT R0 x4005
MOVS R1 x02
STR R1 R0

; loop forever
@loop
    B @loop

</code></pre>
<h2>Next Steps</h2>
<p>Partway through this I realized my assembler syntax doesn't exactly resemble what's in the ARM
manual (e.g. ARM would indicate a load like <code>LDR R1 [R0]</code>, but chasm syntax is <code>LDR R1 R0</code>). I don't
know if it's relevant in the practical sense (<em>edit from the future: it is</em>), but I'll probably
spend some time aligning at least that bit.</p>
<p>Also, the repetition of the sequence of load/store operations piqued my interest, so I might try to
introduce function calls. If that goes smoothly, I still want to cycle through RGB colors, but to do
that I'll need to use one of the system timers, so that may happen, too.</p></div>
    </body>
</html>
