<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Interactive Digital</title>
        <link rel="stylesheet" type="text/css" href="../static/style.css" />
        <link rel="preconnect" href="https://rsms.me/" />
        <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
    </head>

    <body class="px-2">
        <div class="py-4">
            <div class="flex flex-row items-baseline pb-2">
                <a href="/">
                    <div
                        class="text-[calc(50vw/8)] tracking-[-0.03em] leading-none font-semibold"
                    >
                        Interactive Digital
                    </div>
                </a>
                <nav>
                    <a
                        class="text-blue-600 visited:text-purple-600 px-2 py-0.5 ml-4 after:content-['â†—']"
                        href="/posts/posts.html"
                    >
                        <span class="text-sm text-gray-600 font-semibold"
                            >Posts</span
                        >
                    </a>
                </nav>
            </div>
            <hr class="md:hidden" />
        </div>
        <div class="post-content max-w-prose px-2"><h2>Metal ARM x03 - Toggle LED (Lab Notes)</h2>
<aside>
  Metal ARM is a series of projects for learning native toolchain development and
  embedded programming "from scratch." For additional context, see
  <a href="https://bferris413.github.io/posts/metal_arm_intro.html">this introductory post</a>.
  <br>
  <br>
  This post is formatted as a set of lab/shop notes: rough around the edges, to the point, light on
  prose.
</aside>
<p>Project 3 consists of:</p>
<ul>
<li>Responding to button presses, where each press toggles the red LED.</li>
</ul>
<h2>Work Completed</h2>
<ul>
<li>Updated syntax to use register dereferences like <code>LDR R1 [R0]</code> (added <code>[]</code>)</li>
<li>Added support for label references like <code>&amp;label</code>, which evaluates to the address of <code>@label</code></li>
<li>Extended branching to support not-yet-defined labels (like <code>B &amp;label ... @label</code>)</li>
<li>Added support for &quot;pseudo&quot; instructions. These are assembler-interpreted operations
that simplify some redundant or common behavior that would be onerous to do manually. Examples:
<ul>
<li><code>pad-with-to!(&lt;byte&gt;, &lt;target_address&gt;)</code> - fill <code>[current_address, target_address)</code> with <code>byte</code></li>
<li><code>thumb-addr!(&lt;address&gt;)</code> - convert <code>address</code> to a thumb address (<code>address | 1</code>)</li>
</ul>
</li>
<li>Added the following instructions to <code>chasm assemble</code>:
<ul>
<li><code>EORS</code></li>
<li><code>BX</code></li>
</ul>
</li>
<li>Flashed and tested on EK-TM4C123GXL, and we can toggle the red LED with Button #2 on the board.
<ul>
<li>Used <code>chasm assemble 3.cas</code> on chasm commit <a href="https://github.com/bferris413/chasm-toolchain/tree/8a2ef01e3f5ff169bd933a4e87d7742312c69899"><code>8a2ef01e3f5ff169bd933a4e87d7742312c69899</code></a></li>
</ul>
</li>
<li>Read a ton of the <a href="https://www.ti.com/lit/ds/symlink/tm4c123gh6pm.pdf?ts=1759278523305&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FTM4C123GH6PM">board reference manual</a> and the <a href="https://developer.arm.com/documentation/ddi0403/ee">Arm v7 Architecture Reference</a>. New information included:
<ul>
<li>Extending the vector table to include a GPIO port event handler (GPIO F in this case, for the button presses)</li>
<li>Setting pins on GPIO to be used as input</li>
<li>Enabling different activation triggers (pull-up, edge-detect, level-detect, etc.)</li>
<li>Enabling the nested vector interrupt controller (NVIC) for GPIO (port F, specifically)</li>
<li>Actually enabling interrupts on GPIO F</li>
<li>Implementing the event handler
<ul>
<li>
<p>The final logic works but doesn't seem idiomatic, specificaly around dealing with race
conditions and my toggle behavior. When pressing the button, sometimes I get a flicker/burst
on the LED.</p>
<p>I rubber-ducked the symptoms off ChatGPT and showed my assembly, and it suggested
changing the way I clear the interrupt, turning off interrupts while in the handler, and adding
a short busy-loop as a debounce. I never tested those ideas out since I figured I implemented enough for the current iteration and the light <em>does</em> toggle =).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The full assembly program is:</p>
<pre><code class="language-chasm-assembly">; vector table -------------------------------
x2000.8000                      ; sp starting address
thumb-addr!(&amp;reset)             ; reset handler address | 1 (thumb mode)
pad-with-to!(x00, x0000.00B8)   ; skip to 0xB8, GPIO F interrupt handler address
thumb-addr!(&amp;button-press)      ; GPIO F button press event handler | 1 (thumb mode)
pad-with-to!(x00, x0000.026C)   ; pad out the rest of the vtable
; --------------------------------------------

@reset
    ; enable clock at RCGCGPIO - x400F.E608 
    ; set bit 5 to 1
    MOVW R0 xE608
    MOVT R0 x400F
    LDR R1 [R0]
    MOVS R2 x20             ; bits[5] = 1
    ORRS R1 R2
    STR R1 [R0]

    ; We need to use the AHB (vs. APB), AHB is the only option supported
    ; by the board but it's not set on reset
    MOVW R0 xE06C 
    MOVT R0 x400F
    LDR R1 [R0]
    MOVS R2 x20             ; bits[5] = 1
    ORRS R1 R2
    STR R1 [R0]

    ; wait for GPIO F to be ready for use via PRGPIO
    MOVW R0 xEA08 
    MOVT R0 x400F
    MOVS R2 x20

    @waitready
        LDR R1 [R0]
        ANDS R1 R2
        BEQ &amp;waitready


    ; Set direction of GPIO port F pins: LED -&gt; output, button -&gt; input 
    ; GPIODIR register at offset x400, set pins[1..=3] to 1
    ; bits[0] and bits[4] are implicitly 0 (inputs)
    MOVW R0 xD400
    MOVT R0 x4005
    LDR R1 [R0]
    MOVS R2 x0E             ; bits[1..=3] = 1, bits[0,4] = 0
    ORRS R1 R2
    STR R1 [R0]

    ; Enable pullup on GPIO F[4]
    ; GPIOPUR register at offset x510, set pins[4] to 1
    MOVW R0 xD510
    MOVT R0 x4005
    LDR R1 [R0]
    MOVS R2 x10             ; bits[4] = 1
    ORRS R1 R2
    STR R1 [R0]

    ; Enable as digital I/O
    ; offset at x51C, pins 1, 2, 3, 4 set to 1
    MOVW R0 xD51C
    MOVT R0 x4005
    LDR R1 [R0]
    MOVS R2 x1E             ; bits[1..=4] = 1
    ORRS R1 R2
    STR R1 [R0]

    ; Set GPIOIS (cleared is edge-detect, set is level-detect)
    ; Since it's cleared on reset, do nothing

    ; Set GPIOIEV (cleared is falling-edge, set is rising-edge)
    ; Since it's cleared on reset, do nothing

    ; Enable NVIC interrupt handling
    ; GPIO F is interrupt 30, corresponding to bits[30] at xE000.E000,
    ; offset x100
    MOVW R0 xE100
    MOVT R0 xE000
    LDR R1 [R0]
    MOVS R2 x00
    MOVT R2 x4000           ; bits[30] = 1
    ORRS R1 R2
    STR R1 [R0]

    ; Enable interrupt on GPIOF[4]
    ; GPIOIM register at offset x410, set pins[4] to 1
    MOVW R0 xD410
    MOVT R0 x4005
    LDR R1 [R0]
    MOVS R2 x10             ; bits[4] = 1
    ORRS R1 R2
    STR R1 [R0]

    @wait-for-event
        B &amp;wait-for-event


; Toggle red LED, GPIO F pin 1
@button-press
    ; clear interrupt
    ; offset x41C, port F at x4005.D000, pins[4]
    MOVW R0 xD41C
    MOVT R0 x4005
    MOVS R5 x10
    LDR R1 [R0]     ; Lack of atomics is now glaring, need to figure that out
    ORRS R1 R5
    STR R1 [R0]     

    ; we'll read GPIO F data at offset x03FC, which is the masked addr
    ; for mask xFF. Also, realized this is a bit unsafe if we get interrupted
    ; since we're writing all bits. Baby steps
    MOVW R0 xD3FC
    MOVT R0 x4005
    LDR R1 [R0]
    MOVS R2 x02    ; bits[1] (pin 1)
    EORS R1 R2
    STR R1 [R0]

    ; return
    ; load EXC_RETURN (pre-loaded into LR) into PC
    BX LR    

</code></pre>
<h2>Next Steps</h2>
<p>I mentioned in <a href="https://bferris413.github.io/posts/metal_arm_2.html">Project 2</a> that repeating the
same setup code is kind of onerous, and I felt the same in this project. In the next project I'd
like to add chasm support for function calls and some kind of <code>include</code> statement. This implies
multiple source files, and would be the first foray into a primitive linking step.</p>
<p>Depending on how that goes I'll either wrap it up <em>or</em> try to cover an embedded feature. Not having
any debug printing has been kind of painful, so maybe investigating and implementing that is next.</p></div>
    </body>
</html>
